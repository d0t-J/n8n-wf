{
  "active": false,
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download file": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Cohere": {
      "ai_embedding": [
        [
          {
            "node": "Supabase Vector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Supabase Vector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Supabase Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-11-14T08:45:42.634Z",
  "id": "ZNalse890ZcOmolM",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "My workflow 10",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "a7895d10-f258-4892-a8bf-139fceef9ee5",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "authentication": "serviceAccount",
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "1E3w_p40q5umgBh4CpjclZAYlp-t5TnHX",
          "mode": "list",
          "cachedResultName": "Edifyt.txt",
          "cachedResultUrl": "https://drive.google.com/file/d/1E3w_p40q5umgBh4CpjclZAYlp-t5TnHX/view?usp=drivesdk"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        208,
        0
      ],
      "id": "9d0bd413-27f8-4fda-808a-686b23defdb6",
      "name": "Download file",
      "credentials": {
        "googleApi": {
          "id": "oWq8fcswkYhVgLyv",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        416,
        0
      ],
      "id": "64cd3c63-eeb8-4c70-a815-c21e272b06d7",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "documents",
          "mode": "list",
          "cachedResultName": "documents"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1.3,
      "position": [
        832,
        0
      ],
      "id": "e05468f2-cef1-468a-95c5-0c704cadeb79",
      "name": "Supabase Vector Store",
      "credentials": {
        "supabaseApi": {
          "id": "KjM7GVXVYPrZNNF8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "modelName": "embed-english-v3.0"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsCohere",
      "typeVersion": 1,
      "position": [
        784,
        208
      ],
      "id": "4a7448fa-77f5-4537-b03b-341bc1ce87a9",
      "name": "Embeddings Cohere",
      "credentials": {
        "cohereApi": {
          "id": "qM82BRiYi9xNnlOp",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "textSplittingMode": "custom",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1.1,
      "position": [
        976,
        208
      ],
      "id": "01b27bea-8ff4-4229-9bb7-0be39a3b6c81",
      "name": "Default Data Loader"
    },
    {
      "parameters": {
        "chunkSize": 950,
        "chunkOverlap": 150
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        960,
        416
      ],
      "id": "6575a924-b286-4c04-85c5-5cc47b0bb360",
      "name": "Character Text Splitter"
    },
    {
      "parameters": {
        "jsCode": "// This code is designed to run in an n8n Code Node.\n// It prioritizes extracting the page data array from common nested paths.\n\n// --- Helper Functions (Keep these outside the main logic block) ---\n\nfunction cleanText(text) {\n    if (typeof text !== 'string') return \"\";\n    return text.replace(/[\\r\\n\\t]/g, ' ')\n               .replace(/\\s\\s+/g, ' ') \n               .trim();\n}\n\nfunction chunkText(text, chunkSize = 1200, overlap = 150) {\n    text = cleanText(text);\n    if (!text || text.length <= chunkSize) return [text];\n\n    const chunks = [];\n    let start = 0;\n\n    while (start < text.length) {\n        let end = start + chunkSize;\n        const lastPeriod = text.lastIndexOf(\". \", end);\n        const lastNewLine = text.lastIndexOf(\"\\n\", end);\n        const breakPoint = Math.max(lastPeriod, lastNewLine);\n\n        if (breakPoint > start + chunkSize * 0.5) {\n            end = breakPoint + 1;\n        }\n\n        chunks.push(text.slice(start, end).trim());\n        start = end - overlap;\n    }\n\n    return chunks.filter(chunk => chunk.length > 50);\n}\n\n// --- Main Execution Logic ---\n\nconst inputItems = $input.all();\nlet pageObjects = [];\n\n// 1. ROBUST PARSING: Extracting the array of page objects\nif (inputItems.length > 0) {\n    const firstItem = inputItems[0].json;\n\n    // A. Attempt to parse the deeply nested, escaped string (from file analysis)\n    if (firstItem && typeof firstItem.data === 'string' && firstItem.data.startsWith('am[')) {\n        try {\n            const innerJsonString = firstItem.data.substring(2).trim();\n            const parsedData = JSON.parse(innerJsonString);\n            if (Array.isArray(parsedData)) {\n                pageObjects = parsedData;\n            } else if (parsedData && Array.isArray(parsedData.data)) {\n                 // Check if the nested JSON itself has a 'data' property that is the array\n                 pageObjects = parsedData.data;\n            } else if (parsedData && typeof parsedData === 'object') {\n                 // Handle case where the escaped string was a single object, push it\n                 pageObjects.push(parsedData);\n            }\n        } catch (e) {\n            // Error logged, move to next check\n            console.error(\"Failed to parse deeply nested escaped string.\", e);\n        }\n    }\n    \n    // B. Fallback 1: Check if the whole data array is simply at inputItems[0].json\n    if (pageObjects.length === 0 && Array.isArray(firstItem)) {\n        pageObjects = firstItem;\n    }\n\n    // C. Fallback 2: Check if the data array is directly nested under a 'data' property (common with 'Execute Command' or JSON parsing)\n    if (pageObjects.length === 0 && firstItem && Array.isArray(firstItem.data)) {\n        pageObjects = firstItem.data;\n    }\n}\n\n\n// Check if we successfully extracted anything before proceeding\nif (pageObjects.length === 0) {\n    // Return an array with a message if no data was found\n    return [{ json: { error: \"No page objects found after robust parsing. Check input data path.\", inputItems: inputItems } }];\n}\n\n\n// 2. CHUNKING AND METADATA GENERATION (The rest of the logic remains the same)\nconst processedChunks = pageObjects.flatMap((data, pageIndex) => {\n    const chunks = [];\n\n    // --- Clean and set base metadata ---\n    // Ensure the data object is valid before processing\n    if (typeof data !== 'object' || data === null) return [];\n\n    const courseTitle = cleanText(data.course?.courseTitle || \"\");\n    const baseMeta = {\n        url: cleanText(data.url || \"\"),\n        title: cleanText(data.title || \"Untitled\"),\n        type: courseTitle ? \"course\" : \"page\",\n        courseTitle: courseTitle,\n        canonical: cleanText(data.canonical || \"\"),\n    };\n\n    // 1. Course Description (if exists) - High priority\n    if (data.course?.courseDesc) {\n        const desc = cleanText(data.course.courseDesc);\n        const descChunks = chunkText(desc, 1200, 150);\n        descChunks.forEach((chunk, idx) => {\n            chunks.push({\n                json: {\n                    text: `Course Description: ${baseMeta.courseTitle}\\n\\n${chunk}`,\n                    metadata: {\n                        ...baseMeta,\n                        contentType: \"course_description\",\n                        chunkIndex: idx,\n                        priority: \"high\",\n                    },\n                },\n            });\n        });\n    }\n\n    // 2. Course Outline (Structured Lists) - High priority\n    if (data.outlineItems && data.outlineItems.length > 0) {\n        const outlineText =\n            `COURSE OUTLINE for ${baseMeta.courseTitle}:\\n` +\n            data.outlineItems.map((item, i) => `${i + 1}. ${cleanText(item)}`).join(\"\\n\");\n            \n        const outlineChunks = chunkText(outlineText, 1000, 100); \n        outlineChunks.forEach((chunk, idx) => {\n            chunks.push({\n                json: {\n                    text: chunk,\n                    metadata: {\n                        ...baseMeta,\n                        contentType: \"course_outline\",\n                        chunkIndex: idx,\n                        priority: \"high\",\n                    },\n                },\n            });\n        });\n    }\n\n    // 3. Main Content (metaDescription + rawText) - Medium priority\n    if (data.rawText || data.metaDescription) {\n        const mainContent = [\n            data.metaDescription ? `Description: ${cleanText(data.metaDescription)}` : \"\",\n            cleanText(data.rawText || \"\"),\n        ]\n            .filter(Boolean)\n            .join(\"\\n\\n\");\n\n        const contentChunks = chunkText(mainContent, 1200, 150);\n        contentChunks.forEach((chunk, idx) => {\n            chunks.push({\n                json: {\n                    text: `Page: ${baseMeta.title}\\n\\n${chunk}`,\n                    metadata: {\n                        ...baseMeta,\n                        contentType: \"main_content\",\n                        chunkIndex: idx,\n                        priority: \"medium\",\n                    },\n                },\n            });\n        });\n    }\n\n    // 4. Page Structure (Headings) - Low priority\n    if (data.headings && data.headings.length > 0) {\n        const headingsText = data.headings\n            .map((h) => `${cleanText(h.tag)}: ${cleanText(h.text)}`)\n            .join(\"\\n\");\n\n        if (headingsText.length > 150) { \n            chunks.push({\n                json: {\n                    text: `Page Structure/Sections: \\n${headingsText}`,\n                    metadata: {\n                        ...baseMeta,\n                        contentType: \"headings\",\n                        priority: \"low\",\n                    },\n                },\n            });\n        }\n    }\n\n    // 5. General Lists - Low priority\n    if (data.lists && data.lists.length > 0) {\n        data.lists.forEach((list, listIdx) => {\n            const listText =\n                `${cleanText(list.nearestHeading || baseMeta.title || \"List\")}:\\n` +\n                (list.items || []).map((item) => `• ${cleanText(item)}`).join(\"\\n\");\n                \n            const listChunks = chunkText(listText, 800, 50); \n            listChunks.forEach((chunk, idx) => {\n                chunks.push({\n                    json: {\n                         text: chunk,\n                        metadata: {\n                            ...baseMeta,\n                            contentType: \"list\",\n                            listIndex: listIdx,\n                            chunkIndex: idx,\n                            priority: \"low\",\n                        },\n                    },\n                });\n            });\n        });\n    }\n\n    return chunks;\n});\n\nreturn processedChunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        19.5
      ],
      "id": "c97f901d-cbcf-42e3-8e5e-a1b9b039b55d",
      "name": "Code in JavaScript"
    }
  ],
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "updatedAt": "2025-11-14T08:45:42.639Z",
      "createdAt": "2025-11-14T08:45:42.639Z",
      "role": "workflow:owner",
      "workflowId": "ZNalse890ZcOmolM",
      "projectId": "POJtR4euQRkudXYs"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-11-14T11:09:56.000Z",
  "versionId": "d3efd015-6f6a-4477-b19b-9c7392cba6e3"
}